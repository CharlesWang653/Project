{"ast":null,"code":"'use strict';\n\nconst defineKey = require('../document/compile').defineKey;\n\nconst get = require('../get');\n\nconst utils = require('../../utils');\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true\n};\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name + '\" can only be a discriminator of the root model');\n  }\n\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base, 'options.applyPluginsToDiscriminators', false); // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  }\n\n  const key = model.schema.options.discriminatorKey;\n  const existingPath = model.schema.path(key);\n\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey(key, null, model.prototype, null, [key], model.schema.options);\n  }\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name + '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n\n  if (typeof tiedValue == 'string' && tiedValue.length) {\n    value = tiedValue;\n  }\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n\n    if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {\n      const originalSchema = schema;\n      utils.merge(schema, originalSchema);\n      delete schema.paths._id;\n      delete schema.tree._id;\n    } // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n\n\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n\n    for (let i = 0; i < baseSchemaPaths.length; ++i) {\n      if (schema.nested[baseSchemaPaths[i]]) {\n        conflictingPaths.push(baseSchemaPaths[i]);\n      }\n    }\n\n    utils.merge(schema, baseSchema, {\n      omit: {\n        discriminators: true\n      },\n      omitNested: conflictingPaths.reduce((cur, path) => {\n        cur['tree.' + path] = true;\n        return cur;\n      }, {})\n    }); // Clean up conflicting paths _after_ merging re: gh-6076\n\n    for (let i = 0; i < conflictingPaths.length; ++i) {\n      delete schema.paths[conflictingPaths[i]];\n    } // Rebuild schema models because schemas may have been merged re: #7884\n\n\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function (newName) {\n        if (newName === value) {\n          return value;\n        }\n\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ? existingPath.instance : String;\n    schema.add(obj);\n    schema.discriminatorMapping = {\n      key: key,\n      value: value,\n      isRoot: false\n    };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n\n    for (let i = 0; i < keys.length; ++i) {\n      const _key = keys[i];\n\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key + ' (can only modify ' + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') + ')');\n        }\n      }\n    }\n\n    schema.options = utils.clone(baseSchema.options);\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n\n    schema.options.id = id;\n    schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n    schema.plugins = Array.prototype.slice(baseSchema.plugins);\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  } // merges base schema into new discriminator schema and sets new type field.\n\n\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = {\n      key: key,\n      value: null,\n      isRoot: true\n    };\n  }\n\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name]) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};","map":null,"metadata":{},"sourceType":"script"}