{"ast":null,"code":"'use strict';\n\nconst Mixed = require('../schema/mixed');\n\nconst get = require('../helpers/get');\n\nconst util = require('util');\n\nconst utils = require('../utils');\n\nconst populateModelSymbol = require('../helpers/symbols').populateModelSymbol;\n/*!\n * ignore\n */\n\n\nclass MongooseMap extends Map {\n  constructor(v, path, doc, schemaType) {\n    if (v != null && v.constructor.name === 'Object') {\n      v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);\n    }\n\n    super(v);\n    this.$__parent = doc != null && doc.$__ != null ? doc : null;\n    this.$__path = path;\n    this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;\n    this.$__runDeferred();\n  }\n\n  $init(key, value) {\n    checkValidKey(key);\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n  }\n\n  $__set(key, value) {\n    super.set(key, value);\n  }\n\n  set(key, value) {\n    checkValidKey(key); // Weird, but because you can't assign to `this` before calling `super()`\n    // you can't get access to `$__schemaType` to cast in the initial call to\n    // `set()` from the `super()` constructor.\n\n    if (this.$__schemaType == null) {\n      this.$__deferred = this.$__deferred || [];\n      this.$__deferred.push({\n        key: key,\n        value: value\n      });\n      return;\n    }\n\n    const fullPath = this.$__path + '.' + key;\n    const populated = this.$__parent != null && this.$__parent.$__ ? this.$__parent.populated(fullPath) || this.$__parent.populated(this.$__path) : null;\n\n    if (populated != null) {\n      if (value.$__ == null) {\n        value = new populated.options[populateModelSymbol](value);\n      }\n\n      value.$__.wasPopulated = true;\n    } else {\n      try {\n        value = this.$__schemaType.applySetters(value, this.$__parent, false, this.get(key));\n      } catch (error) {\n        if (this.$__parent != null && this.$__parent.$__ != null) {\n          this.$__parent.invalidate(fullPath, error);\n          return;\n        }\n\n        throw error;\n      }\n    }\n\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n\n    if (this.$__parent != null && this.$__parent.$__) {\n      this.$__parent.markModified(this.$__path + '.' + key);\n    }\n  }\n\n  delete(key) {\n    this.set(key, undefined);\n    super.delete(key);\n  }\n\n  toBSON() {\n    return new Map(this);\n  }\n\n  toObject(options) {\n    if (get(options, 'flattenMaps')) {\n      const ret = {};\n      const keys = this.keys();\n\n      for (const key of keys) {\n        ret[key] = this.get(key);\n      }\n\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  toJSON() {\n    const ret = {};\n    const keys = this.keys();\n\n    for (const key of keys) {\n      ret[key] = this.get(key);\n    }\n\n    return ret;\n  }\n\n  inspect() {\n    return new Map(this);\n  }\n\n  $__runDeferred() {\n    if (!this.$__deferred) {\n      return;\n    }\n\n    for (let i = 0; i < this.$__deferred.length; ++i) {\n      this.set(this.$__deferred[i].key, this.$__deferred[i].value);\n    }\n\n    this.$__deferred = null;\n  }\n\n}\n\nif (util.inspect.custom) {\n  Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: MongooseMap.prototype.inspect\n  });\n}\n\nObject.defineProperty(MongooseMap.prototype, '$__set', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\nObject.defineProperty(MongooseMap.prototype, '$__parent', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\nObject.defineProperty(MongooseMap.prototype, '$__path', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\nObject.defineProperty(MongooseMap.prototype, '$__schemaType', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\nObject.defineProperty(MongooseMap.prototype, '$isMongooseMap', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\nObject.defineProperty(MongooseMap.prototype, '$__deferredCalls', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n/*!\n * Since maps are stored as objects under the hood, keys must be strings\n * and can't contain any invalid characters\n */\n\nfunction checkValidKey(key) {\n  const keyType = typeof key;\n\n  if (keyType !== 'string') {\n    throw new TypeError(\"Mongoose maps only support string keys, got \".concat(keyType));\n  }\n\n  if (key.startsWith('$')) {\n    throw new Error(\"Mongoose maps do not support keys that start with \\\"$\\\", got \\\"\".concat(key, \"\\\"\"));\n  }\n\n  if (key.includes('.')) {\n    throw new Error(\"Mongoose maps do not support keys that contain \\\".\\\", got \\\"\".concat(key, \"\\\"\"));\n  }\n\n  if (utils.specialProperties.has(key)) {\n    throw new Error(\"Mongoose maps do not support reserved key name \\\"\".concat(key, \"\\\"\"));\n  }\n}\n\nmodule.exports = MongooseMap;","map":null,"metadata":{},"sourceType":"script"}