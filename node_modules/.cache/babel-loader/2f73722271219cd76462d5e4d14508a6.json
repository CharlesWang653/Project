{"ast":null,"code":"'use strict';\n\nconst symbols = require('../../schema/symbols');\n\nconst utils = require('../../utils');\n/*!\n * ignore\n */\n\n\nmodule.exports = applyHooks;\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = ['deleteOne', 'save', 'validate', 'remove', 'updateOne', 'init'];\n/*!\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n  model.$appliedHooks = true;\n\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    let childModel = null;\n\n    if (type.$isSingleNested) {\n      childModel = type.caster;\n    } else if (type.$isMongooseDocumentArray) {\n      childModel = type.Constructor;\n    } else {\n      continue;\n    }\n\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n\n    applyHooks(childModel, type.schema, options);\n\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n\n      for (let j = 0; j < keys.length; ++j) {\n        applyHooks(childModel.discriminators[keys[j]], childModel.discriminators[keys[j]].schema, options);\n      }\n    }\n  } // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n\n  const middleware = schema.s.hooks.filter(hook => {\n    if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n      return !!hook['document'];\n    }\n\n    if (hook.name === 'remove') {\n      return hook['document'] == null || !!hook['document'];\n    }\n\n    return true;\n  }).filter(hook => {\n    // If user has overwritten the method, don't apply built-in middleware\n    if (schema.methods[hook.name]) {\n      return !hook.fn[symbols.builtInMiddleware];\n    }\n\n    return true;\n  });\n  model._middleware = middleware;\n  objToDecorate.$__save = middleware.createWrapper('save', objToDecorate.$__save, null, kareemOptions);\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\n  objToDecorate.$__validate = middleware.createWrapper('validate', objToDecorate.$__originalValidate, null, kareemOptions);\n  objToDecorate.$__remove = middleware.createWrapper('remove', objToDecorate.$__remove, null, kareemOptions);\n  objToDecorate.$__deleteOne = middleware.createWrapper('deleteOne', objToDecorate.$__deleteOne, null, kareemOptions);\n  objToDecorate.$__init = middleware.createWrapperSync('init', objToDecorate.$__init, null, kareemOptions); // Support hooks for custom methods\n\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n\n  for (const method of customMethods) {\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n\n    const originalMethod = objToDecorate[method];\n\n    objToDecorate[method] = function () {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = utils.last(args);\n      const argsWithoutCallback = typeof cb === 'function' ? args.slice(0, args.length - 1) : args;\n      return utils.promiseOrCallback(cb, callback => {\n        return this[\"$__\".concat(method)].apply(this, argsWithoutCallback.concat([callback]));\n      }, model.events);\n    };\n\n    objToDecorate[\"$__\".concat(method)] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}